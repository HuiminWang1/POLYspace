utils::globalVariables(c(
  "x", "y", "xend", "yend"
))

#' Generate edge data from a neighborhood topology
#'
#' Convert different representations of a cell neighborhood topology
#' (singlet, pair, or adjacency matrix) into edge data.
#'
#' @param ta Neighborhood topology input.
#' @return A data.frame with columns \code{from} and \code{to}.
#'
#'
#' @export
generateEdgeData = function(ta){
  
  if(identical('singlet',ta)){
    ta = matrix(1)
  }
  if(identical('pair',ta)){
    ta = matrix(c(0,1,1,0),2,2)
  }
  rn = composition = value = NULL
  edge_full = which(ta == 1, arr.ind = TRUE)
  find_unique_edge = reshape2::melt(edge_full)
  data.table::setDT(find_unique_edge)
  colnames(find_unique_edge) = c('rn','variable','value')
  data.table::setorder(find_unique_edge, rn, value)
  find_unique_edge[, composition := paste(value, collapse = "--"), by = rn]
  urn = find_unique_edge[, .(urn = data.table::first(rn)), by = composition]
  edge_data = edge_full[urn$urn,,drop=FALSE]
  edge_data = data.frame(edge_data)
  colnames(edge_data) = c('from','to')
  return(edge_data)
  
}


#' Generate node data from a neighborhood string
#'
#' Parse a neighborhood-encoded string into node-level data,
#' separating nodes and extracting region and cell type information.
#'
#' @param string A character string encoding neighborhood nodes.
#'   Nodes are separated by \code{delimiter_node}, and each node
#'   encodes region and cell type separated by
#'   \code{delimiter_region_celltype}.
#' @param delimiter_node A character delimiter used to separate nodes.
#'   Default is \code{"--"}.
#' @param delimiter_region_celltype A character delimiter used to split
#'   region and cell type within a node. Default is \code{"_"}.
#'
#' @return A data.frame containing node-level information, such as
#'   node id, region, and cell type.
#'
#' @export
generateNodedata = function(string,
                            delimiter_node = '--',
                            delimiter_region_celltype = '_'){
  
  labels = strsplit(string, delimiter_node, fixed = TRUE)[[1]]
  regions = ifelse(grepl(delimiter_region_celltype, labels), 
                   sub(paste0(delimiter_region_celltype, ".*"), "", labels), NA)
  celltypes = sub(paste0(".*",delimiter_region_celltype), "", labels)
  
  node_data = data.frame(region = regions,
                         celltype = celltypes,
                         label = labels,
                         id = 1:length(labels),
                         #target = data$target[match(string,data$neighborhood)],
                         stringsAsFactors = FALSE)
  return(node_data)
  
  
}


#' Generate arc geometry for a neighborhood glyph
#'
#' Compute arc-level geometry used to render region- or cell-typeâ€“specific
#' arcs in a cell neighborhood glyph.
#'
#' @param node_data A data.frame of node-level information, typically
#'   generated by \code{generateNodeData()}.
#' @param arc_center A numeric vector of length 2 specifying the (x, y)
#'   center of the glyph.
#' @param arc_radius A numeric vector specifying outer and inner arc radii.
#'   Default is \code{c(1, 0.9)}.
#' @param arc_scale A numeric vector of length 2 specifying anisotropic
#'   scaling factors applied to arc geometry in the x and y directions.
#'   The first value corresponds to the x-axis scale, and the second
#'   to the y-axis scale. Default is \code{c(0.7, 1)}.
#' @param arc_angle A numeric vector of length 2 specifying the start and
#'   end angles (in radians) of the arc. Default is
#'   \code{c(3*pi/10, 7*pi/10)}.
#' @param arc_length_out Integer specifying the number of points used
#'   to approximate each arc.
#'
#' @return A list containing arc geometry.
#'
#' @export
generateArcData = function(node_data,
                           arc_center,
                           arc_radius = c(1,0.9), 
                           arc_scale = c(0.7,1),
                           arc_angle = c(3*pi/10, 7*pi/10), 
                           arc_length_out = 100){
  
  regions = sort(unique(node_data$region))
  if(length(regions)>0){
    arc_data = list()
    if(length(regions) == 1){
      regions = c(regions,'dummy')
    }
    n_arc = length(regions)
    theta = seq(arc_angle[1], arc_angle[2], length.out = arc_length_out)
    for(i in 1:n_arc){
      
      arc_data[[i]] = data.frame(
        x = arc_radius[i] * cos(theta)*arc_scale[1]+arc_center[1],
        y = arc_radius[i] * sin(theta)*arc_scale[2]+arc_center[2]
      )
    }
    names(arc_data) = regions
    return(arc_data)
  }
  
}

#' Generate node positions for a neighborhood glyph
#'
#' Compute node-level (x, y) positions for placing nodes relative to
#' region-specific arcs in a cell neighborhood glyph.
#'
#' @param node_data A data.frame containing node-level information,
#'   produced by \code{generateNodeData()}.
#' @param arc_center A numeric vector of length 2 specifying the (x, y)
#'   center of the glyph.
#' @param node_scale A list of numeric vectors of length 2 specifying
#'   x- and y-axis scaling factors for node placement.
#'   Each element in the list corresponds to one region.
#'   Default is \code{list(c(0.4, 0.4), c(0.4, 0.4))}.
#' @param node_xjust A numeric vector specifying horizontal justification
#'   offsets applied to node positions.
#'   Each value corresponds to one region.
#'   Default is \code{c(0, 0)}.
#' @param node_yjust A numeric vector specifying vertical justification
#'   offsets applied to node positions.
#'   Each value corresponds to one region.
#'   Default is \code{c(2.5, -0.4)}.
#'
#' @return A data.frame containing node coordinates and associated
#'   node attributes.
#'
#' @export
generateNodePosition = function(node_data, 
                                arc_center, 
                                node_scale = list(c(0.4,0.4),
                                                  c(0.4,0.4)),
                                node_xjust = c(0,0),
                                node_yjust = c(2.5,-0.4)) {
  
  regions = unique(node_data$region)
  
  if(!identical(NA,regions)){
    node_data_split = split(node_data,node_data$region)
    
    node_position = list()
    n_region = length(node_data_split)
    
    
    for(i in 1:n_region){
      node_n = nrow(node_data_split[[i]])
      anchor = arc_center+c(node_xjust[i],node_yjust[i])
      if(node_n == 1){
        
        node_position[[i]] = data.frame(x = anchor[1],
                                        y = anchor[2],
                                        celltype = node_data_split[[i]]$celltype,
                                        region = node_data_split[[i]]$region,
                                        id = node_data_split[[i]]$id)
        
      }else{
        
        angle = 2 * pi / node_n 
        node_position[[i]] = data.frame(x = anchor[1]+node_scale[[i]][1] * cos(angle * (1:node_n - 1)),
                                        y = anchor[2]+node_scale[[i]][2] * sin(angle * (1:node_n - 1)),
                                        celltype = node_data_split[[i]]$celltype,
                                        region = node_data_split[[i]]$region,
                                        id = node_data_split[[i]]$id)
        
      }
      
    }
    
    node_position = do.call('rbind',node_position)
    node_position[,'ta'] = node_data$ta
  }else{
    
    node_n = nrow(node_data)
    anchor = arc_center
    
    angle = 2 * pi / node_n 
    
    if (node_n == 2) {
      angle = c(pi/2, -pi/2)
      node_position = data.frame(x = anchor[1]+node_scale[[1]][1] * cos(angle),
                                 y = anchor[2]+node_scale[[1]][2] * sin(angle),
                                 celltype = node_data$celltype,
                                 region = node_data$region,
                                 id = node_data$id)
    } else {
      angle = 2 * pi / node_n 
      node_position = data.frame(x = anchor[1]+node_scale[[1]][1] * cos(angle * (1:node_n - 1)),
                                 y = anchor[2]+node_scale[[1]][2] * sin(angle * (1:node_n - 1)),
                                 celltype = node_data$celltype,
                                 region = node_data$region,
                                 id = node_data$id)
    }
    
  }
  
  
  return(node_position)
}







#' Construct a cell neighborhood glyph
#'
#' Generate a topology-aware glyph that visually encodes a cell
#' neighborhood by combining cell types, regions, and their adjacency
#' structure into a compact graphical representation.
#'
#' @param string A character string encoding neighborhood nodes.
#'   Nodes are separated by \code{delimiter_node}, and each node encodes
#'   region and cell type separated by \code{delimiter_region_celltype}.
#' @param adjmat An adjacency matrix specifying the neighborhood topology
#'   between nodes.
#' @param delimiter_node A character delimiter used to separate nodes in
#'   \code{string}. Default is \code{"--"}.
#' @param delimiter_region_celltype A character delimiter used to split
#'   region and cell type within a node. Default is \code{"_"}.
#' @param region_color_plate A named character vector specifying colors
#'   for each region.
#' @param celltype_color_plate A named character vector specifying colors
#'   for each cell type.
#' @param dummy_arc_color A named character vector specifying the color
#'   used for a dummy region arc when only a single region is present.
#'   In this case, the dummy arc serves as a placeholder to indicate that
#'   all cell types are contained within the same region.
#'   Default is gray.
#'
#' @param arc_position A numeric vector of length 2 specifying the (x, y)
#'   center of the glyph.
#' @param arc_radius A numeric vector specifying inner and outer arc radii.
#'   Default is \code{c(1, 0.9)}.
#' @param arc_scale A numeric vector of length 2 specifying x- and y-axis
#'   scaling factors applied to arc geometry. Default is \code{c(0.7, 1)}.
#' @param arc_angle A numeric vector of length 2 specifying the angular
#'   positions (in radians) used to place region-specific arcs.
#'   Each value corresponds to one region. Default is
#'   \code{c(3*pi/10, 7*pi/10)}.
#' @param arc_length_out Integer specifying the number of points used to
#'   approximate each arc.
#' @param arc_width Numeric specifying the line width of arcs.
#' @param arc_text_color Character specifying text color for region labels.
#'   Use \code{"default"} to inherit region colors.
#' @param arc_text_x A numeric vector specifying x positions for region
#'   text labels.
#' @param arc_text_y A numeric vector specifying y positions for region
#'   text labels.
#' @param arc_text_size Numeric specifying text size for region labels.
#' @param arc_text_fontface Character specifying font face for region labels.
#'
#' @param node_scale A list of numeric vectors of length 2 specifying
#'   x- and y-axis scaling factors for node placement.
#'   Each list element corresponds to one region.
#' @param node_xjust A numeric vector specifying horizontal offsets applied
#'   to node positions, one per region.
#' @param node_yjust A numeric vector specifying vertical offsets applied
#'   to node positions, one per region.
#'
#' @param network_edge_color Character specifying color for network edges.
#' @param node_text_size Numeric specifying text size for node labels.
#' @param node_text_hjust Numeric specifying horizontal justification
#'   applied to node text labels.
#' @param node_text_vjust Numeric specifying vertical justification
#'   applied to node text labels.
#' @param node_text_fontface Character specifying font face for node labels.
#'
#' @param xlims Numeric vector specifying x-axis limits for the glyph.
#' @param ylims Numeric vector specifying y-axis limits for the glyph.
#'
#' @return A ggplot object representing the cell neighborhood glyph.
#'
#' @details
#' This function integrates node parsing, topology encoding, and geometric
#' layout to construct a compact glyph representation of a cell
#' neighborhood. It is intended for summarizing local spatial structures
#' rather than precise spatial coordinates.
#'
#' @export
neighborhoodArcGlyph = function(string,
                                 adjmat,
                                 delimiter_node = '--',
                                 delimiter_region_celltype = '_',
                                 region_color_plate = NULL,
                                 celltype_color_plate,
                                 dummy_arc_color = c(dummy = 'gray'),
                                 arc_position = c(0,0),
                                 arc_radius = c(1,0.9), 
                                 arc_scale = c(0.7,1),
                                 arc_angle = c(3*pi/10,7 * pi/10), 
                                 arc_length_out = 100,
                                 arc_width = 3,
                                 arc_text_color = 'default',
                                 arc_text_x = c(0.7,0.7),
                                 arc_text_y = c(0.9,0.7),
                                 arc_text_size = 4,
                                 arc_text_fontface = 'plain',
                                 node_scale = list(c(0.4,0.4),
                                                   c(0.4,0.4)),
                                 node_xjust = c(0,0),
                                 node_yjust = c(1.3,0.6),
                                 network_edge_color = 'black',
                                 node_text_size = 3, 
                                 node_text_hjust = 0.5,
                                 node_text_vjust = 0.5,
                                 node_text_fontface = 'plain',
                                 xlims = c(-1,1),
                                 ylims = c(0,2)){
  
  
  region_color_plate = c(region_color_plate,dummy_arc_color)
  if(identical('default',arc_text_color)){
    arc_text_color = region_color_plate
  }
  #preparing edge data
  edge_data = generateEdgeData(adjmat)
  
  #preparing node data
  
  node_data = generateNodedata(string = string,
                               delimiter_node = delimiter_node,
                               delimiter_region_celltype = delimiter_region_celltype)
  
  
  # drawing arcs
  # generating arc centers
  
  
  arc_center = c(x = arc_position[1],
                 y = arc_position[2])
  # generating arc data
  arc_data = generateArcData(node_data = node_data,
                             arc_center = arc_center,
                             arc_radius = arc_radius, 
                             arc_scale = arc_scale,
                             arc_angle = arc_angle, 
                             arc_length_out = arc_length_out)
  
  pl = ggplot2::ggplot()
  if(!is.null(arc_data)){
    for(j in 1:length(arc_data)){
      
      pl = pl + 
        ggplot2::geom_path(data = arc_data[[j]],
                  ggplot2::aes(x = x, y = y),
                  color = region_color_plate[names(arc_data)[j]],
                  linewidth = arc_width)
      if(names(arc_data)[j]!='dummy'){
        pl = pl + 
          ggplot2::annotate("text", x =  arc_center[1]+arc_text_x[j],
                   y = arc_center[2]+arc_text_y[j],
                   label = names(arc_data)[j],
                   color = arc_text_color[names(arc_data)[j]],
                   size = arc_text_size,
                   fontface = arc_text_fontface)
        
      }
      
    }
  }
  
  
  
  
  
  # generating node positions
  
  
  node_position = generateNodePosition(node_data = node_data,
                                       arc_center = arc_center,
                                       node_scale = node_scale,
                                       node_xjust = node_xjust,
                                       node_yjust = node_yjust)
  
  
  # drawing edges
  
  segment_data = data.frame(x = node_position$x[match(edge_data$from,node_position$id)], 
                            y = node_position$y[match(edge_data$from,node_position$id)], 
                            xend = node_position$x[match(edge_data$to,node_position$id)], 
                            yend = node_position$y[match(edge_data$to,node_position$id)])
  pl = pl + ggplot2::geom_segment(data = segment_data,
                         ggplot2::aes(x = x, y = y, xend = xend, yend = yend), color = network_edge_color)
  # drawing nodes
  
  pl = pl + ggplot2::annotate("label",
                     x = node_position$x, 
                     y = node_position$y,
                     label = node_position$celltype,
                     color = celltype_color_plate[node_position$celltype], 
                     size = node_text_size, 
                     hjust = node_text_hjust,
                     vjust = node_text_vjust,
                     fontface = node_text_fontface)
  
  pl = pl+
    ggplot2::theme_void()+
    ggplot2::xlim(xlims[1], xlims[2]) +
    ggplot2::ylim(ylims[1], ylims[2])
  
  return(pl)
  
}


